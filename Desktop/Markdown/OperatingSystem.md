# Operating System

* 没有安装操作系统,计算机**依然可以运行程序**
* 普通用户不能正常使用

#### 操作系统功能和定义
1. 进程管理(CPU管理)
* 进程控制: 创建,暂停,唤醒,撤销
* 进程调度: 调度策略,优先级
* 进程通信: 进程间通信
2. 内存管理
* 内存分配
* 内存共享
* 内存保护
* 虚拟内存
3. 设备管理
* 设备管理和调度
* 设备无关性
* 设备传输控制
* 设备驱动
4. 文件管理
* 存储空间操作
* 文件操作
* 目录操作
* 文件和目录存取权限的管理
#### 操作系统定义
* 提供用户**接口**
* 负责为应用程序**分配和调度软硬件资源**, 控制与协调程序并发活动,帮助用户存取等等
#### 操作系统历史

**用户需求提升**和**硬件技术进步**是操作系统发展两大动力
**计算机硬件发展**的四个典型阶段:

1. 电子管
2. 晶体管
3. 集成电路
4. 大规模集成电路

**操作系统**发展的四个典型阶段

1. 手工
2. 单道批处理系统(批量,自动,单道)
	将多个作业输入到磁盘形成作业队列
	操作系统依次自动处理队列中的每个作业
	外设和CPU交替空闲和忙碌,利用效率低
3. 多道批处理系统(多道,并行(宏观),串行(微观))
	存放**多道程序**
	缺点:作业处理时间长,交互能力差,运行时间不确定
4. 分时系统


#### 分时技术与分时操作系统

* 中断技术, 通道技术: 专门处理外设与内存之间数据传输的处理机(通道)
多终端计算机: 
	* 高性能主机 + 多个终端
		* 主机:运算,CPU强大,大容量内存
		* 终端: 输入和显示,通过串口线远程连接至主机
	采用分时技术轮流为每个终端服务

**分时技术**:	主机以**很短**的**时间片**为单位,把CPU轮流分给每个终端使用,直到作业全被执行完.由于**时间片**很短,每个终端都能很快重新获得CPU,得到及时响应.

**等待周期** = **时间片** $\times$ 终端数量

#####　分时系统的特点
* 多路调制性:**多用户**联机使用同一台计算机
* 交互性: 及时响应
* 独占性: 用户感觉独占计算机

* 大型分时系统的实践:Multics

##### UNIX
* 第一个**实用化**的分时操作系统
* 实现了操作系统的**可移植性**
* 实现了硬件无关性
* 引进了特殊文件的概念: 
		把外设看作文件,实现统一管理

#### 典型操作系统类型
* 微机操作系统
* 多处理机
* 网络
* 实时
* 嵌入式
##### 微机系统
Control Program Microprocessor 
* 良好的层次结构,**BIOS**将操作系统和硬件分隔
Mac OSxi
* 最早使用图形界面和鼠标的操作系统
MS DOS
* 磁盘操作系统
* 单用户单任务
Windows
##### 实时操作系统
产生背景:某些任务**优先紧急**处理
强调作业完成时限

##### 嵌入式
约等于实时操作系统

* 软硬件可以裁剪,软硬件一体化
* 典型的嵌入式操作系统: Android,Linux,ucOS

##### 网络操作系统

在普通操作系统的基础上增加了网络通信和网络服务的功能,常见的操作系统都是网络操作系统UNIX,LINUX,WINDOWS

* 网络资源透明存取
* 存取控制

### 操作系统逻辑结构

* 设计逻辑和实现思路

1. 整体式
2. 层次式
3. 微内核式

##### 整体式

以**模块**为基本单位构建

特点：

* 模块设计，编码，调试独立
* 模块调度自由
* 通信多以**全局变量**完成，

缺点：

* 信息传递随意，维护和更新困难

##### 层次式

TCP/IP协议栈，越往底层和硬件联系越紧密，越往上层和用户联系越紧密

分层原则：

* 硬件相关——最底层
* 外部特性——最外层
* 中间层——调用次序或消息传递顺序
* 共性的服务——较低层
* 活跃功能——较低层

优点： 

* 结构清晰，避免循环调用
* 整体问题局部化，系统的正确性容易保证
* 有利于操作系统的扩充，维护和移植

##### 微内核

微内核 + 核外服务器

微内核： 提供os最基本的核心功能和服务

* 实现与硬件紧密相关的处理
* 实现一些较基本的功能
* 负责客服和服务器间的通信
  核外服务器： 完成os的绝大部份服务功能，等待应用程序提出请求
* 由若干服务器或者进程共同构成

### CPU的态

支持OS最基本的硬件结构：

1. CPU
2. 内存
3. 中断
4. 时钟

### CPU态

CPU的工作状态，也是一种对资源和指令使用权限的描述

态主要可分为3类：

1. 核态（kernel mode), 可访问所有资源，使用所有指令，管理程序或OS内核
2. 用户态(User mode)，可访问部分资源，权限受限，用户程序
3. 管态(Supervisor mode)，介于二者之间

#### 用户态和核态的相互转换

用户态向核态转换：

* 用户请求OS提供服务
* 发生中断
* 用户进程产生错误（产生中断）
* 用户态企图执行特权指令

核态向用户态转换：

* 中断返回：IRET

#### 硬件和OS对CPU的观察

* 硬件按照**态**，核态或者用户态，来区分CPU的状态
* OS按**进程**来区分CPU的状态，进程A，进程B，还是进程C

##### Intel CPU的态

* Ring0～Ring3（0为最核心，3为最外层）
* 程序A访问程序B时需要进行权限的检查，也就是对态的检查，比较DPL和RPL
* RPL描述程序段的属性

#### 存储程序和数据的部件

* 按照读写的工作方式： RAM， ROM
* 按照与CPU的联系： 主存，辅存。即是否与CPU交换信息

##### 分级存储系统的工作原理

CPU读取指令或数据时访问顺序：

1. 首先访问高速缓存Cache中的数据，如果需要访问的数据在Cache中，称之为命中
2. 如果没有命中，则CPU会到主存中访问，如果没有，则MISS
3. 再到辅存中访问，如果辅存中也没有，则称之为缺页

### 中断机制

* CPU对突发外部事件反应过程或机制
* CPU收到**外部信号**(中断信号),停止当前工作,转去处理该**外部信号**,处理完毕之后回到原来工作的**中断处**(断点)继续原来的工作
* 引入中断的目的
	1. 实现并发活动
	2. 实现实时处理
	3. 故障自动处理
#### 中断的一些基本概念
中断源: 引起系统中断的事件

中断类型: 强迫性中中断和自愿中断

* 强迫性: 程序没有预期,例如: **I/O**,**外部中断**
* 自愿中断: 程序有预期的,例如: **执行访管指令**

外中断(**中断**)和内中断(**俘获**)

* 外中断:由CPU外部事件引起, 例如:  **I/O**, 外部事情
* 内中断: 由CPU内部事件引起. 例如: 访管中断,程序中断

外中断: 不可屏蔽和可屏蔽

* 不可屏蔽中断: 中断的原因很紧要,CPU必须响应
* 可屏蔽中断: 中断的原因不很紧要,CPU可以不必响应

断点: 程序将要执行的下一个指令的地址

现场: 程序正确运行所依赖的信息集合

* 相关寄存器的内容

现场的**两个**处理过程

* 现场的保护: 进入中断服务程序之前,将寄存器的值入栈
* 现场的恢复: 退出中断服务程序之后,出栈

#### 中断响应过程

1. 识别中断源
2. 保护断点和现场
3. 装入**中断服务程序的入口地址**
4. 进入中断服务程序
5. 恢复现场和断点
6. 中断返回(**IRET**)

#### 中断响应的实质

* 交换指令执行地址的过程(CS:IP发生变化,)
* 交换了CPU的态:主程序在**用户态**完成,中断程序在**核态**完成
* 工作:现场保护和恢复.通信

## 操作系统用户界面

### 操作系统启动过程

1. 操作系统启动过程
实模式和保护模式
* 实模式(REAL MODE,刚刚开机)

* 程序按照8086寻址方法,1MB空间

* 前面640K [00000~9FFFF]: 基本内存

* 中间128K [A0000~BFFFF]: 显卡显存

* 末尾256K [C0000~FFFFF]: BIOS
	 * 显卡BIOS
	    * IDE控制器BIOS
	    * 系统**BIOS**(重点)
	* 寻址方式: 物理地址(20位) = 段地址(16位):偏移地址(16位)
	* CPU单任务运行
	
* 保护模式(内存模式,PROTECT MODE)
	* 寻址方式: 段(**32位**)和偏移量(**32位**),
	* 可寻址**4GB**空间
	* 段页式寻址机制
	* 虚拟地址,进程,封闭空间
	* CPU支持多任务
	* 应用程序和操作系统的运行环境都被**保护**(保护了内存)
	
#### 系统BIOS

* 系统启动配置
	* 基本设备IO服务
	* 系统加电自检和启动
	
	按下**PowerOn**或者Reset执行第一条指令
	
	* 执行FFFF0处的指令: **JUMP POST** ,跳转到**加电自检**处.
	
	加电自检Power On Self-Test
	
	* 初始化基本硬件(CPU,内存,显卡)
	* 自检正常不提示,错误则喇叭提示
	
	加电自检完成后:
	
	* 查找BIOS,调用显卡BIOS
	* 查找其他设备执行相应设备的BIOS
	* 显示启动画面
	* 读入OS,OS接管计算机 
	
#### [主启动记录](MBR)

* 存放在硬盘/软盘的首扇区
	* 存放和OS启动的相关信息,如路径,需要的参数等
	* 512MB
	* 结束于0xAA55H
	
##### MBR/硬盘分区/格式化

硬盘的**第一个扇区**存放MBR, 即主启动扇区.剩下的分区的首扇区记录特殊的内容,称为**分区启动信息**
	
首扇区的最前面也有一块特殊的内容,称之为[主启动扇区](PBR) , 用于启动操作系统和加载操作系统
	
###### BIOS和MBR程序运行过程

1. POST $\rightarrow$ CMOS设置(硬盘启动) $\rightarrow$  读取MBR $\rightarrow$ 控制权交给MBR
2. MBR读取[分区表](Partion Table) $\rightarrow$ 找到[活动分区](Active Partion) , 并确认其他分区都是不活动分区 $\rightarrow$ 读取活动分区的[第一个分区](分区引导记录PBR) $\rightarrow$ 加载到内存
3. PBR继续控制后面的引导过程
### 操作系统的启动
* 启动过程: 从**加电** 到**用户工作环境**准备好的过程
1. 初始引导
2. 核心初始化
3. 系统初始化
#### 初始引导
* 把OS核心(以文件的方式存在在硬盘上)装入内存,并使之开始工作接管操作系统

  * 加点,JUMP POST  
  
  * BIOS中的启动程序运行
  
  启动程序: 读取[MBR](0面0道第1扇区)的内容,加载MBR中的引导程序
  
  引导程序: 根据相关参数,读取硬盘指定位置的文件到内存
  
  加载硬盘上的OS内核,并初始化基本参数
  

#### 核心初始化

* OS内核初始化系统的核心数据
* 各种寄存器的初始化
* 存储系统和页表的初始化
* 核心进程的构建

#### 系统初始化

* 为用户使用系统做准备,使系统处于待命状态

#### Windows启动

1. POST
*  加电吼BIOS启动主机自检
2. 初始引导
* BIOS从MBR读入**引导程序**, 装入内存的特定位置
* 引导程序启动DOS7.0,调入操作系统核心
* WINDOWS接管系统
3. 核心初始化
* 资源状态,核心数据初始化
4. 系统初始化
* GUI界面生成, 系统处于待命/消息接受状态

### 操作系统生成
* 满足特定硬件环境和用户需要，**组装**和**构建**操作系统的过程
#### 主要步骤
* 根据硬件环境/用户配置功能模块和构造参数
* **[构建](build)OS的映像**

#### OS生成的前提

* OS由可拆装模块构成
* 有交互式配置工具（改变现有参数）
* 有映像[构建](build)工具，将第二步获得的源代码编译

##### LINUX 

1. 获取Linux源代码
2. 选择和启动内核配置程序
3. 根据需要配置内核模块和参数
4. 重新编译新的内核
5. 编译和安装新的模块
6. 启动新内核

### OS用户界面

* OS提供给用户控制计算机的机制，又称用户接口

用户界面的分类：

* 操作界面
* 系统调用

#### 操作界面

* 图形用户接口（GUI,Graphic User Interface）

  包括窗口，图标，菜单，按钮，鼠标

* 键盘命令（COMMAND)

  * 在控制台下接受键盘输入的命令
  * 类型： 普通命令，批处理程序，shell

#### Shell脚本编程

[脚本](Script)通过类似程序的方式执行具有一定逻辑顺序的命令序列完成较复杂的功能和人机交互

* 脚本程序保存在**文本文件**中
* 脚本程序是Shell命令语句的集合

mkdir:创建路径
ldconfig:使配置文件生效
rm: 删除文件
-rf(参数)表示删除文件夹中的一个子目录

* 执行Shell脚本文件需要具有[可执行属性](x)
``Chmod + x MyScript.sh``来添加可执行属性

##### 运行脚本程序的三个方法
1. 直接运行(使用缺省版本的Shell运行)
2. 使用某个特定版本的Shell执行脚本
```bash
$ bash first_script
```

* 指定一个特定版本的shell版本(此例是**bash**)
* 逐行执行脚本中的命令
* 当脚本文件中的命令依次执行完毕,临时子shell**自动结束运行**,返回用户原来使用的shell
3. 在脚本文件**首行**指定shell
* 在脚本文件开头增加一行``#!/bin/bash --#!必须顶格,后面接shell全路径
* 可以从/etc/shell获知所有可用shell及其绝对路径



## 进程管理
* 重点掌握**线程**,**同步和P-V操作**, **Windows和Linux同步机制**,**进程通信**

OS区别与应用软件最核心的功能在于OS有进程管理功能和内存管理功能，如果一个应用软件具有上述两个功能我们可以把他看做一个OS

### 进程概念
#### 进程的基本概念
* 程序在并发环境中的问题:
1. 运行过程不确定,一个程序什么时候暂停什么时候继续,程序员无法控制.完全由操作系统控制
2. 结果不可再现.可能受到干扰,干扰的结果不可确定
解决方案: 对运行过程施加相互约束
* 新的概念:进程
  描述和管理程序**运行过程**
  程序在某个数据集合上的**一次** **运行活动**
* 数据集合: 软/硬件环境,多个进程共存/共享的环境
* 进程的特性:
1. 动态性
进程是程序的一次执行过程,动态地产生/消亡
2. 并发性
进程同其他进程一起向前推进
3. 异步性
进程按照各自的速度向前推进
4. 独立性
进程是OS分配资源和调度CPU的单位

######　进程和程序的区别
* 静态和动态
1. 进程是动态的:程序的一次执行过程
2. 程序是静态的:一组指令的有效集合
* 暂存和长存
1. 进程是暂存的: 在**内存**上驻留
2. 程序是长存的: 在介质上长期保存
* 程序和进程的对应
一个程序可能有多个进程
##### 进程的类型
* 按照使用资源的权限
1. 系统进程:指系统内核相关和进程
2. 用户进程: 指运行于用户态的进程
* 按对CPU的依赖性
1. 偏CPU进程: 计算型进程: 如科学计算等
2. 偏I/O进程: 侧重于I/O的进程

#### 进程状态

* 运行状态(Running)
进程已经占有CPU,在CPU上运行,对于大多数计算机来说只有一个CPU所以只有一个进程能够真正的占用CPU
* 就绪状态(Ready)
具备运行条件,但由于**无CPU**,暂时不能运行
* 阻塞状态(Block)或等待状态(Wait)
因为等待某项服务完成或信号不能运行的状态,如等待: 系统调用, I/O操作, 合作进程信号

#####　进程状态的变迁
进程的状态可以依据一定的条件相互转化．
1. 就绪$ \rightarrow$ 运行
 进程调度
 2. 运行$ \rightarrow$ 就绪
 时间片到了,或者优先级更高的进程抢占了CPU
 3. 运行$ \rightarrow$ 阻塞
 请求OS提供服务,等待某个信号的到来
 4. 阻塞$ \rightarrow$ 就绪
 等待的服务完成 了,等待的信号到来了

 #### 进程控制块(Process Control Block)
 * 描述进程状态,资源,和相关进程关系的**数据结构**
 * PCB是进程的**标志**
 * 创建进程时创建PCB,进程撤销后PCB同时撤销


进程= 程序 + PCB. 程序包含代码和数据

###### PCB的数据结构
1. name(ID): 进程名称,标识符
2. status: 状态
3. next: 指向下一个PCB的指针
4. start_addr: 程序地址
5. priority: 优先级
6. cpu_status: 现场保留区(堆栈)
7. comm_info: 进程通信
8. process_family: 家族
9. own_resource: 资源

##### 进程的切换
* 进程的上下文:Context,进程的运行环境,CPU环境
进程的切换过程
* 换入进程的上下文进入CPU,从**栈**上读入,同时更新寄存器的信息
* 换出进程的上下文离开CPU,保存到**栈**中,将来CPU重新读取进程的时候就从栈上读取






