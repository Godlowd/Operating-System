# Operating System

* 没有安装操作系统,计算机**依然可以运行程序**
* 普通用户不能正常使用

#### 操作系统功能和定义
1. 进程管理(CPU管理)
* 进程控制: 创建,暂停,唤醒,撤销
* 进程调度: 调度策略,优先级
* 进程通信: 进程间通信
2. 内存管理
* 内存分配
* 内存共享
* 内存保护
* 虚拟内存
3. 设备管理
* 设备管理和调度
* 设备无关性
* 设备传输控制
* 设备驱动
4. 文件管理
* 存储空间操作
* 文件操作
* 目录操作
* 文件和目录存取权限的管理
#### 操作系统定义
* 提供用户**接口**
* 负责为应用程序**分配和调度软硬件资源**, 控制与协调程序并发活动,帮助用户存取等等

#### 操作系统的特性
* 并发性: 同时处理多个任务的能力
* 共享性: 为多个并发任务提供资源共享
* 不确定性: 具有处理随机事件的能力,例如处理终端,自动化处理能力

#### 操作系统历史

**用户需求提升**和**硬件技术进步**是操作系统发展两大动力
**计算机硬件发展**的四个典型阶段:

1. 电子管
2. 晶体管
3. 集成电路
4. 大规模集成电路

**操作系统**发展的四个典型阶段

每一类操作系统是如何**提升CPU/设备利用率的**

1. 手工
2. 单道批处理系统(批量,自动,单道)
	将多个作业输入到磁盘形成作业队列
	操作系统依次自动处理队列中的每个作业
	外设和CPU交替空闲和忙碌,利用效率低
3. 多道批处理系统(多道,并行(宏观),串行(微观))
	存放**多道程序**
	缺点:作业处理时间长,交互能力差,运行时间不确定
4. 分时系统


#### 分时技术与分时操作系统

* 中断技术, 通道技术: 专门处理外设与内存之间数据传输的处理机(通道)
多终端计算机: 
	* 高性能主机 + 多个终端
		* 主机:运算,CPU强大,大容量内存
		* 终端: 输入和显示,通过串口线远程连接至主机
	采用分时技术轮流为每个终端服务

**分时技术**:	主机以**很短**的**时间片**为单位,把CPU轮流分给每个终端使用,直到作业全被执行完.由于**时间片**很短,每个终端都能很快重新获得CPU,得到及时响应.

**等待周期** = **时间片** $\times$ 终端数量

##### 分时系统的特点
* 多路调制性:**多用户**联机使用同一台计算机
* 交互性: 及时响应
* 独占性: 用户感觉独占计算机

* 大型分时系统的实践:Multics

##### UNIX
* 第一个**实用化**的分时操作系统
* 实现了操作系统的**可移植性**
* 实现了硬件无关性
* 引进了特殊文件的概念: 
把外设看作文件,实现统一管理

#### 典型操作系统类型
* 微机操作系统
* 多处理机
* 网络
* 实时
* 嵌入式
* 分布式
##### 微机系统
Control Program Microprocessor 
* 良好的层次结构,**BIOS**将操作系统和硬件分隔
Mac OSxi
* 最早使用图形界面和鼠标的操作系统
MS DOS
* 磁盘操作系统
* 单用户单任务
Windows
##### 实时操作系统
产生背景:某些任务**优先紧急**处理
强调作业完成时限

##### 嵌入式
约等于实时操作系统,实时OS可以看作嵌入式OS的一个分支

* 软硬件可以裁剪,软硬件一体化,考虑成本造价需求等自己选择硬件和OS.
* 典型的嵌入式操作系统:Linux,ucOS

##### 网络操作系统

在普通操作系统的基础上增加了网络通信和网络服务的功能,常见的操作系统都是网络操作系统UNIX,LINUX,WINDOWS

* 网络资源透明存取
* 存取控制

### 操作系统评价指标
* 吞吐率: 单位时间处理信息的能力
* 响应能力: 从接收数据到输出结果的时间间隔
* 资源利用率: 设备的使用频度(CPU,内存等等),以更优化的调度和管理方式让CPU尽可能的忙碌.
* 可移植性:改变硬件环境仍能正常工作的能力(**代码修改量**)
* 可靠性:发现,诊断和恢复系统故障的能力



### 操作系统逻辑结构

* 设计逻辑和实现思路

1. 整体式
2. 层次式
3. 微内核式

##### 整体式

以**模块**为基本单位构建

特点：

* 模块设计，编码，调试独立
* 模块调度自由
* 通信多以**全局变量**完成，

缺点：

* 信息传递随意，维护和更新困难

##### 层次式

TCP/IP协议栈，越往底层和硬件联系越紧密，越往上层和用户联系越紧密

分层原则：

* 硬件相关——最底层
* 外部特性——最外层
* 中间层——调用次序或消息传递顺序
* 共性的服务——较低层
* 活跃功能——较低层

优点： 

* 结构清晰，避免循环调用
* 整体问题局部化，系统的正确性容易保证
* 有利于操作系统的扩充，维护和移植

##### Linux内核
Linux = 内核 + shell + X Windows+ 应用程序
宏内核结构
将图形,设备驱动,及文件系统全部功能都在内核实现.
* 优点: 减少通信和状态切换开销,运行效率较高
* 
##### 微内核(客户/服务器结构)

微内核 + 核外服务器

微内核： 提供os最基本的核心功能和服务
* 优点: 内核便于裁剪和移植,稳定性和安全性较高.
* 实现与硬件紧密相关的处理
* 实现一些较基本的功能
* 负责客服和服务器间的通信
  核外服务器： 完成os的绝大部份服务功能，等待应用程序提出请求
* 由若干服务器或者进程共同构成

### CPU的态

支持OS最基本的硬件结构：

1. CPU
2. 内存
3. 中断
4. 时钟

### CPU态

CPU的工作状态，也是一种对资源和指令使用权限的描述

态主要可分为3类：

1. 核态（kernel mode), 可访问所有资源，使用所有指令，管理程序或OS内核
2. 用户态(User mode)，可访问部分资源，权限受限，用户程序
3. 管态(Supervisor mode)，介于二者之间

#### 用户态和核态的相互转换

用户态向核态转换：

* 用户请求OS提供服务
* 发生中断
* 用户进程产生错误（产生中断）
* 用户态企图执行特权指令

核态向用户态转换：

* 中断返回：IRET

#### 硬件和OS对CPU的观察

* 硬件按照**态**，核态或者用户态，来区分CPU的状态
* OS按**进程**来区分CPU的状态，进程A，进程B，还是进程C

##### Intel CPU的态

* Ring0～Ring3（0为最核心，3为最外层）
* 程序A访问程序B时需要进行权限的检查，也就是对态的检查，比较DPL和RPL
* RPL描述程序段的属性

#### 存储程序和数据的部件

* 按照读写的工作方式： 

   RAM

   ROM:固定在主板上,普通用户无法直接更新和拆除

* 按照与CPU的联系： 
 主存:直接与CPU交换信息
辅存:不能直接与CPU交换信息

##### 分级存储系统的工作原理

CPU读取指令或数据时访问顺序：

1. 首先访问高速缓存Cache中的数据，如果需要访问的数据在Cache中，称之为命中
2. 如果没有命中，则CPU会到主存中访问，如果没有，则MISS
3. 再到辅存中访问，如果辅存中也没有，则称之为缺页

### 中断机制

* CPU对突发外部事件反应过程或机制
* CPU收到**外部信号**(中断信号),停止当前工作,转去处理该**外部信号**,处理完毕之后回到原来工作的**中断处**(断点)继续原来的工作
* 引入中断的目的
	1. 实现并发活动
	2. 实现实时处理
	3. 故障自动处理
#### 中断的一些基本概念
中断源: 引起系统中断的事件

断点: 将要执行的下一指令的地址:**CS:IP**

现场: 程序运行所依赖的信息集合.

中断类型: 强迫性中中断和自愿中断

* 强迫性: 程序没有预期,例如: **I/O**,**外部中断**
* 自愿中断: 程序有预期的,例如: **执行访管指令**

外中断(**中断**)和内中断(**俘获**)

* 外中断:由CPU外部事件引起, 例如:  **I/O**, 外部事情
* 内中断: 由CPU内部事件引起. 例如: 访管中断,程序中断

外中断: 不可屏蔽和可屏蔽

* 不可屏蔽中断: 中断的原因很紧要,CPU必须响应
* 可屏蔽中断: 中断的原因不很紧要,CPU可以不必响应

断点: 程序将要执行的下一个指令的地址

现场: 程序正确运行所依赖的信息集合

* 相关寄存器的内容

现场的**两个**处理过程

* 现场的保护: 进入中断服务程序之前,将寄存器的值入栈
* 现场的恢复: 退出中断服务程序之后,出栈

#### 中断响应过程

1. 识别中断源
2. 保护断点和现场
3. 装入**中断服务程序的入口地址**
4. 进入中断服务程序
5. 恢复现场和断点
6. 中断返回(**IRET**)

#### 中断响应的实质

* 交换指令执行地址的过程(CS:IP发生变化,)
* 交换了CPU的态:主程序在**用户态**完成,中断程序在**核态**完成
* 工作:现场保护和恢复.通信

## 操作系统用户界面

* 重点/难点
1. 操作系统启动过程
2. 操作系统生成过程
3. 系统调用机制


### 操作系统启动过程

1. 操作系统启动过程
实模式和保护模式
* 实模式(REAL MODE,刚刚开机)

* 程序按照8086寻址方法,1MB空间

* 前面640K [00000~9FFFF]: 基本内存

* 中间128K [A0000~BFFFF]: 显卡显存

* 末尾256K [C0000~FFFFF]: BIOS
	 * 显卡BIOS
	    * IDE控制器BIOS
	    * 系统**BIOS**(重点)
	* 寻址方式: 物理地址(20位) = 段地址(16位):偏移地址(16位)
	* CPU单任务运行
	
* 保护模式(内存模式,PROTECT MODE)
	* 寻址方式: 段(**32位**)和偏移量(**32位**),
	* 可寻址**4GB**空间
	* 段页式寻址机制
	* 虚拟地址,进程,封闭空间
	* CPU支持多任务
	* 应用程序和操作系统的运行环境都被**保护**(保护了内存)
	
#### 系统BIOS

* 系统启动配置
	* 基本设备IO服务
	* 系统加电自检和启动
	
	按下**PowerOn**或者Reset执行第一条指令
	
	* 执行FFFF0处的指令: **JUMP POST** ,跳转到**加电自检**处.
	
	加电自检Power On Self-Test
	
	* 初始化基本硬件(CPU,内存,显卡)
	* 自检正常不提示,错误则喇叭提示
	
	加电自检完成后:
	
	* 查找BIOS,调用显卡BIOS
	* 查找其他设备执行相应设备的BIOS
	* 显示启动画面
	* 读入OS,OS接管计算机 
	
#### [主启动记录](MBR)

* 存放在硬盘/软盘的首扇区
	* 存放和OS启动的相关信息,如路径,需要的参数等
	* 512MB
	* 结束于0xAA55H
	
##### MBR/硬盘分区/格式化

硬盘的**第一个扇区**存放MBR, 即主启动扇区.剩下的分区的首扇区记录特殊的内容,称为**分区启动信息**
	
首扇区的最前面也有一块特殊的内容,称之为[主启动扇区](PBR) , 用于启动操作系统和加载操作系统
	
###### BIOS和MBR程序运行过程

1. POST $\rightarrow$ CMOS设置(硬盘启动) $\rightarrow$  读取MBR $\rightarrow$ 控制权交给MBR
2. MBR读取[分区表](Partion Table) $\rightarrow$ 找到[活动分区](Active Partion) , 并确认其他分区都是不活动分区 $\rightarrow$ 读取活动分区的[第一个分区](分区引导记录PBR) $\rightarrow$ 加载到内存
3. PBR继续控制后面的引导过程
### 操作系统的启动
* 启动过程: 从**加电** 到**用户工作环境**准备好的过程
1. 初始引导
2. 核心初始化
3. 系统初始化
#### 初始引导
* 把OS核心(以文件的方式存在在硬盘上)装入内存,并使之开始工作接管操作系统

  * 加点,JUMP POST  
  
  * BIOS中的启动程序运行
  
  启动程序: 读取[MBR](0面0道第1扇区)的内容,加载MBR中的引导程序
  
  引导程序: 根据相关参数,读取硬盘指定位置的文件到内存
  
  加载硬盘上的OS内核,并初始化基本参数
  

#### 核心初始化

* OS内核初始化系统的核心数据
* 各种寄存器的初始化
* 存储系统和页表的初始化
* 核心进程的构建

#### 系统初始化

* 为用户使用系统做准备,使系统处于待命状态

#### Windows启动

1. POST
*  加电吼BIOS启动主机自检
2. 初始引导
* BIOS从MBR读入**引导程序**, 装入内存的特定位置
* 引导程序启动DOS7.0,调入操作系统核心
* WINDOWS接管系统
3. 核心初始化
* 资源状态,核心数据初始化
4. 系统初始化
* GUI界面生成, 系统处于待命/消息接受状态

### 操作系统生成
* 满足特定硬件环境和用户需要，**组装**和**构建**操作系统的过程
#### 主要步骤
* 根据硬件环境/用户配置功能模块和构造参数
* **[构建](build)OS的映像**

#### OS生成的前提

* OS由可拆装模块构成
* 有交互式配置工具（改变现有参数）
* 有映像[构建](build)工具，将第二步获得的源代码编译

##### LINUX 

1. 获取Linux源代码

2. 选择和启动内核配置程序
```bash
   make menuconfig
```

   

3. 根据需要配置内核模块和参数

```bash
   Loadable module support	//设置对可加载模块的支持
   Processor type and features	//设置CPU类型
   General setup	//对普通属性的一些设置
   Parallel port support //并口支持
   Plug and Play configuration //即插即用配置
   Block devices	//块设备支持的选项
```

4. 重新编译新的内核
```bash
   make dep	//生成依赖dependency信息
   make clean	//清除旧的编译结果
   make bzImage	//二进制文件
```

5. 编译和安装新的模块
```bash
   make modules
   make modules install	//模块被编译且安装到/usr/lib/内核版本号目录下
```

6. 启动新内核

### OS用户界面

* OS提供给用户控制计算机的机制，又称用户接口

用户界面的分类：

* 操作界面
* 系统调用:系统功能调用,程序界面

#### 操作界面

* 图形用户接口（GUI,Graphic User Interface）

  包括窗口，图标，菜单，按钮，鼠标

* 键盘命令（COMMAND)

  * 在控制台下接受键盘输入的命令
  * 类型： 普通命令，批处理程序，shell

#### Shell脚本编程

[脚本](Script)通过类似程序的方式执行具有一定逻辑顺序的命令序列完成较复杂的功能和人机交互

* 脚本程序保存在**文本文件**中
* 脚本程序是Shell命令语句的集合

mkdir:创建路径
ldconfig:使配置文件生效
rm: 删除文件
-rf(参数)表示删除文件夹中的一个子目录

* 执行Shell脚本文件需要具有[可执行属性](x)
``Chmod + x MyScript.sh``来添加可执行属性

##### 运行脚本程序的三个方法
1. 直接运行(使用缺省版本的Shell运行)
2. 使用某个特定版本的Shell执行脚本
```bash
$ bash first_script
```

* 指定一个特定版本的shell版本(此例是**bash**)
* 逐行执行脚本中的命令
* 当脚本文件中的命令依次执行完毕,临时子shell**自动结束运行**,返回用户原来使用的shell
3. 在脚本文件**首行**指定shell
* 在脚本文件开头增加一行``#!/bin/bash --#!必须顶格,后面接shell全路径
* 可以从/etc/shell获知所有可用shell及其绝对路径

#### 系统调用

* 操作系统**内核**为应用程序提供的**服务**/**函数**

特点: 

1. 一般涉及核心资源或硬件的操作
2. 运行于核态
3. 每个系统调用具有**唯一的编号**
4. 调用过程中会产生**中断**.自愿中断

##### Linux利用INT 80H中断实现系统调用

* 利用**EAX寄存器**存放系统调用的编号

##### 隐式系统调用

* 类似API函数
* 在高级语言中使用
* 在系统内部转换为包含**INT 80H**的指令,执行相应的系统调用

##### Linux系统调用的工作原理



## 进程管理
* 重点掌握**线程**,**同步和P-V操作**, **Windows和Linux同步机制**,**进程通信**

OS区别与应用软件最核心的功能在于OS有进程管理功能和内存管理功能，如果一个应用软件具有上述两个功能我们可以把他看做一个OS

### 进程概念
#### 进程的基本概念
* 程序在并发环境中的问题:
1. 运行过程不确定,一个程序什么时候暂停什么时候继续,程序员无法控制.完全由操作系统控制
2. 结果不可再现.可能受到干扰,干扰的结果不可确定
解决方案: 对运行过程施加相互约束
* 新的概念:进程
  描述和管理程序**运行过程**
  程序在某个数据集合上的**一次** **运行活动**
* 数据集合: 软/硬件环境,多个进程共存/共享的环境
* 进程的特性:
1. 动态性
进程是程序的一次执行过程,动态地产生/消亡
2. 并发性
进程同其他进程一起向前推进
3. 异步性
进程按照各自的速度向前推进
4. 独立性
进程是OS分配资源和调度CPU的单位

######　进程和程序的区别
* 静态和动态
1. 进程是动态的:程序的一次执行过程
2. 程序是静态的:一组指令的有效集合
* 暂存和长存
1. 进程是暂存的: 在**内存**上驻留
2. 程序是长存的: 在介质上长期保存
* 程序和进程的对应
一个程序可能有多个进程
##### 进程的类型
* 按照使用资源的权限
1. 系统进程:指系统内核相关和进程
2. 用户进程: 指运行于用户态的进程
* 按对CPU的依赖性
1. 偏CPU进程: 计算型进程: 如科学计算等
2. 偏I/O进程: 侧重于I/O的进程

#### 进程状态

* 运行状态(Running)
进程已经占有CPU,在CPU上运行,对于大多数计算机来说只有一个CPU所以只有一个进程能够真正的占用CPU
* 就绪状态(Ready)
具备运行条件,但由于**无CPU**,暂时不能运行
* 阻塞状态(Block)或等待状态(Wait)
因为等待某项服务完成或信号不能运行的状态,如等待: 系统调用, I/O操作, 合作进程信号

##### 支持挂起(suspend)和解挂(resume)操作
* 挂起: 用户或者OS将进程有意暂停
* 解挂: 将挂起的进程继续
* 阻塞: 活动阻塞(正常阻塞)和静止阻塞(阻塞时挂起)
* 就绪: 活动就绪(正常就绪)和静止就绪(就绪时挂起)
#####　进程状态的变迁
进程的状态可以依据一定的条件相互转化．
1. 就绪$ \rightarrow$ 运行
 进程调度
 2. 运行$ \rightarrow$ 就绪
 时间片到了,或者优先级更高的进程抢占了CPU
 3. 运行$ \rightarrow$ 阻塞
 请求OS提供服务,等待某个信号的到来
 4. 阻塞$ \rightarrow$ 就绪
 等待的服务完成 了,等待的信号到来了

 #### 进程控制块(Process Control Block)
 * 描述进程状态,资源,和相关进程关系的**数据结构**
 * PCB是进程的**标志**
 * 创建进程时创建PCB,进程撤销后PCB同时撤销


进程= 程序 + PCB. 程序包含代码和数据

###### PCB的数据结构
1. name(ID): 进程名称,标识符
2. status: 状态
3. next: 指向下一个PCB的指针
4. start_addr: 程序地址
5. priority: 优先级
6. cpu_status: 现场保留区(堆栈)
7. comm_info: 进程通信
8. process_family: 家族
9. own_resource: 资源

##### 进程的切换
* 进程的上下文:Context,进程的运行环境,CPU环境
进程的切换过程
* 换入进程的上下文进入CPU,从**栈**上读入,同时更新寄存器的信息
* 换出进程的上下文离开CPU,保存到**栈**中,将来CPU重新读取进程的时候就从栈上读取

<<<<<<< HEAD

### 进程控制

* 进程生存期间对其全部行为的控制

四个典型控制行为: 
1. 创建进程
2. 撤销进程
3. 阻塞进程
4. 唤醒进程
#### 进程创建
* 功能: 创建一个具有指定标识的进程
* 参数: 进程标识,优先级,进程起始地址,CPU初始状态,资源清单
###### 创建进程的过程
1. 创建一个空的PCB
2. 获得并赋予进程标识符ID
3. 为进程分配空间
4. 初始化PCB的成员变量
5. 插入相应的进程队列(新进程插入就绪队列)
我们总是默认新创建的进程是**就绪的** ,只要给他CPU立刻就可以运行

#### 进程撤销
* 功能: 撤销一个指定的进程,收回进程所占有的资源,撤销该进程的PCB
* 撤销进程的时机/事件
1. 正常结束
2. 异常结束
3. 外界干预
* 参数: 被撤销的进程ID
###### 撤销的过程
1. 在PCB队列中检索出该PCB
2. 获取该进程的状态
3. 若该进程处在运行态,立即终止该进程
这里我们需要注意,在OS中,一个操作系统可能有**父进程**也可能有**子进程**,如果要被撤销的进程存在**子进程**,那么我们需要先撤销他的**子进程**(递归过程)
4. 释放进程所占有的资源
5. 将进程从PCB队列移除

##### 进程阻塞

* 功能: 停止进程的执行.变为阻塞
* 阻塞的时间/事件
1. 请求系统服务:由于某种原因,OS不能立即满足进程的要求
2. 启动某种操作: 进程启动某种操作,阻塞等待该进程执行完毕
3. 新数据尚未到达: A进程需要获得B进程的**中间结果** A进程等待
4. 无新工作可做: 进程完成任务后,**自我阻塞** 等待新任务到达
* 参数: **阻塞原因**, 不同的阻塞原因构建不同的阻塞队列

##### 阻塞的实现
1. 停止运行
2. 将PCB**运行态**改为**阻塞态**
3. 插入相应原因的阻塞队列
4. 转调度程序

#### 进程唤醒
* 功能: 唤醒处于**阻塞队列**当中的某个进程
* 参数: 被唤醒进程的ID
* 引起唤醒的时机/事件
1. 系统服务由不满到满足
2. I/O完成
3. 新数据到达
4. 进程提出新请求(服务)

#### 进程控制原语
* 由若干指令构成的具有特定功能的函数
* 具有**原子性**,操作不可分割,要么执行成功,要么执行失败,中途不可停下
  

进程控制原语:
1. 创建
2. 撤销
3. 阻塞
4. 唤醒

### Windows控制进程

* 创建进程的方法: 点击图标,启动/创建进程

### Linux进程控制
* 创建进程fork(),返回一个pid_t的整形值
例如,``pid_t pid = fork()``
* 新建进程是当前进程的**子进程**,在Linux中所有的进程都具有家族关系
* 父进程与子进程
父进程: fork()的调用者
子进程: 新建的进程
* 子进程是父进程的复制,具有和父进程相同的代码,数据,堆栈,差别在于**ID**号不一样,与时间有关的信息不一样
```C
int main(void)
{
 	fork();
 	printf("Hello World\n");
 	return 0;
}
```

在屏幕上会输出两个Hello World的字符串

```C
int main(void)
{
    pid_t pid;
    pid = fork();
    if(pid == 0)
        printf("Hello World\n");
    else if(pid > 0)
        printf("How are you\n");
    return 0;
}
```

此时在屏幕上输出一行``Hello World``与一行``How are you``.
在子进程中,``pid=0``,在父进程中``pid>0``(子进程ID),如果执行出错,返回-1
但是父进程,子进程是**并发的**,所以字符串输出顺序**不确定**.不会无限循环和递归创建子进程.

#### 子进程和父进程的并发

当父进程中的``pid = fork()``指令执行时,复制相同的代码到子进程.``fork()``指令之前的指令**不再执行**,从指令后面的语句并发.

#### fork函数的实现
```C
int do_fork(
	unsigned long clone_flags,
	unsigned long stack_start,
	struct pt_regs *regs,
	unsigned long stack_size
);
int do_fork{
    struct task_struct *p;
    p = alloc_task_struct();//分配存放位置的内存
    ......
    copy_files(clone_flags,p);
    copy_fs(clone_flags,p);
    copy_mm(clone_flags,p);//拷贝进程所有信息
    ......
    wake_up_process(p);//唤醒进程,挂入可执行队列等待被调度
    ......
}
```
* Linux启动以后的第一个进程是**init进程**,所有其他进程都是init的子孙
#### exec函数簇

* 装入一个**指定的可执行程序**运行
* **使子进程具有和父进程完全不同的新功能**

步骤:
* 根据文件名找到相应的可执行程序
* 将可执行程序的内容填入子进程的地址空间
* 进入新进程执行且不再返回

### 线程
#### 线程概念
* 由CPU可以直接运行的实体,程序内部的执行路径
* 一个进程可以创建多个线程
* 多个线程**共享**CPU可以实现并发运行


* CreateThread()
把一个函数创建为一个线程
##### 单线程程序和多线程程序
* 单线程: 整个进程只有一个线程,Windows程序默认只有一个线程(主线程:main线程)
* 多线程:整个进程至少有两个线程,**主线程**和**至少一个用户线程**

#### 线程典型应用场景
1. 程序的多个功能需要并发运行
例如同时画圆和画方, 暴风影音(在线看电影)(视频解码,音频解码,网络接收)
为每一个功能创建为一个线程,从而实现多功能的并发
2. 提高**窗口程序**的交互性
3. 需要改善程序结构的地方
4. 多核CPU上的应用
##### 创建线程的补充说明
* Win32库创建线程: CreateThread(线程函数,参数)
* MFC创建线程: AfxBeginThread(线程函数,参数)
* 创建远程线程: CreateRemoteThread(进程,线程函数,参数)**这个创建的线程不是在当前控制的进程中**
* Linux创建线程:pthread_create(线程函数,参数)

### 临界区和锁
#### 临界资源和临界区

* 临界资源(Critical Resource): 一次只允许**一个进程**独占访问的资源
* 临界区(Critical Section): 进程中访问临界资源的**程序段**

* 临界区和临界资源的访问特点:
  * 具有排他性
  * 并发进程不能**同时进入**临界区

##### 设计临界区访问机制的四个原则

* 忙则等待: 当临界区忙时,其他进程必须在临界区外等待
* 空闲让进: 当无进程处于临界区时,任何有权进程可以进入临界区
* 有限等待: 进程进入临界区的请求应该在**有限时间**内得到满足
* 让权等待: 等待进程放弃CPU,(让其他进程有机会得到CPU)

##### 临界区的大小设置

临界区既不能设置的**过大**,也不能设置的**过小**

设置的过大程序等待的时间会变成,过小则达不到设置临界区的目的

#### 锁机制

* 基本原理: 设置一个标志"S"，表明临界资源**可用**或者**不可用**
  1. 进入临界区之前检查标志是否**可用**
  2. 如果不可用状态,进程在临界区之外**等待**
  3. 如果可用,访问临界资源,并且设置标志为**不可用**
  4. 退出临界区时将标志设为可用

##### 上锁操作

```C
LOCK(S)		//上锁操作
{
    test: if(S==0)	
        goto test;	//测试锁标志,内部循环
    	else //S==1
            S=0;	//上锁
}
```

##### 开锁操作

```C
UnLock(S)
{
    S = 1;	//开锁
}
```

**开锁原语**
##### 锁机制访问临界区
1. 初始化锁状态S=1(可用)
2. 进入临界区之前执行**上锁**操作
3. 退出临界区之后执行**开锁**操作

#### 同步和P-V操作(重点)

##### 同步和互斥的概念

进程的**互斥**关系: 多个进程由于共享了独占性资源,必须协调各进程对资源的存取顺序,确保没有任何两个或者以上的进程同时进行**存取操作**
* 互斥和资源共享相关
* 资源: 临界资源
* 存取操作区域: 临界区
进程的**同步**关系: 若干**合作进程**为了完成一个共同的任务,需要相互协调运行步伐,**一个进程**开始某个操作**之前**,必须要求**另一个进程**已经完成了某个操作,否则前面的进程只能**等待**
* 合作关系的另一种解释: 合作进程中的某些操作之间需要满足某种**先后关系**或某个操作能否进程需要满足某个**前提条件**,否则只能等待
* 互斥关系属于特殊的同步关系

##### P-V操作的概念

###### 信号灯的概念

* 一种进程同步机制

进程在运行过程中**受信号灯状态控制**, 并能**改变信号灯状态**
* 信号灯的状态可以**阻塞**或者**唤醒**进程
* 信号灯的状态可以被进程改变
###### 信号灯的数据结构
* 定义为一个二元矢量(S,q)
* S: 整数,初值非负(S又称信号量,不与信号灯做区分)
* q: PCB队列,初值为空集
```C
struct SEMAPHORE
{
	int S;	//整数,初值非负
	pointer_PCB q; 	//队列:进程PCB指针,初值空集
}
```
两个操作:
1. P操作: 通过(Passeren)
2. V操作: 释放
* P操作原理
1. S减一
2. 如果**差** $\geq$ 0,该进程继续
3. 如果**差** $\leq$ 0.则该进程阻塞,并加入队列q中,转调度函数
* Q操作原理
1. S加一
2. 如果**和** $\geq$ 0,该进程继续
3. 如果**和** $\leq$ 0.则该进程**继续**, 同时从q中**唤醒**一个进程

##### P-V操作解决互斥问题

* 本质: 实现对临界区的互斥访问
* 应用过程:
  1. 进入临界区之前执行P操作
  2. 离开临界区之后再执行V操作
* S的初值设置合理(似乎s的初值只能设为1)

##### P-V操作解决同步问题
* 同步机制实质: 运行条件不满足时,能让进程暂停;条件满足时能让进程继续
* 基本思路:
1. 暂停当前进程: 在关键操作**之前**执行**P**操作
2. 继续进程: 在关键操作**之后**执行**V**操作
3. 定义合适的信号量S,表示运行条件
* 什么是关键操作:
1. 是否需要条件
2. 完成与否是否影响另外一个进程


#### Windows和Linux同步机制
##### Windows同步机制
* 临界区
* 互斥量
* 信号量
* 事件
* 等待
1. 临界区
* 在进程内使用,保证仅一个线程可以申请到该对象
* 是临界资源的访问
等待函数**WaitForXXXObject**: 等待目标对象变成有信号状态就返回.线程结束的时候会变成有信号状态
```C
DWORD WaitForMultipleObjects
(	
DWORD nCount,		//等待目标对象数量
CONST HANDLE *lpHandles,	//目标对象的句柄数组
BOOL fWaitAll,				//等待方式
DWORD dwMilliseconds);		//等待时间
```
```C
DWORD WaitForSingleObjects
(	
HANDLE hHandles,	//目标对象的句柄
DWORD dwMilliseconds);		//等待时间
```

2. 互斥量(Mutex)
* 保证只有**一个**线程或者进程可以申请到资源
* **可以跨进程使用**
* 可以有名称
* 比临界区耗费更多资源
3. 信号量(Semaphore)
* 允许指定数目的**多个**线程/进程访问临界区
* 一种资源计数器.用于限制并发线程的数量
* 初始值可设为n,则表示允许N个进程/线程**并发访问资源**.
* 可以通过相应函数**增**或者**减**.WaitForSingleObject将信号量减一,ReleaseSemaphore将信号量增一
* 信号量的值大于0时,有信号状态;小于等于0时,为无信号状态

##### Linux父子进程同步
###### wait函数
* 进程调用**wait(int status)**阻塞自己,阻塞到有子进程结束.如果没有则一直阻塞.
wait收集该子进程信息并彻底销毁
* 保存进程退出时的状态,如果忽略退出信息,``pid = wait(NULL)`` 
###### exit函数
* 终结进程,利用status传递进程结束时的状态
* 变成**僵尸状态**,保留部分PCB信息.给**wait**收集
1. 正常结束还是异常结束
2. 占用系统CPU总时间
3. 缺页中断次数
* 调用schedule,选择新进程运行

###### sleep函数
* 进程暂停执行nSecond秒
* 系统暂停调度该进程
* 相当于Windows的suspend,挂起若干秒

###### 父子进程共享普通变量

对于普通变量,父子进程各自操作变量副本.互不影响

###### 父子进程共享文件资源

对于文件,父子进程共享同一文件和读写指针

#### 进程通信

##### Windows中的匿名管道通信
* 管道定义: 进程间的一种通信机制.一个进程A可以通过管道把数据传输给另外一个进程B.前者向管道输入数据,后者向管道输出数据.
* 工作原理:
有读/写两个句柄: ``CreatePipe(Handle W, Handle R)``
通过写 写句柄向管道中写数据``WriteFile(W,Buffer)``或者通过输出重定向 向写句柄写入
通过读 读句柄,从管道读取数据``ReadFile(R,Buffer)``.或者通过输入重定向从读句柄读出
* 仅能用于**父子**或者**兄弟**进程通信
1. 父进程创建管道``CreatePipe(W,R)``
2. 父进程创建子进程``CreateProcess()``
3. 父进程写或读管道,子进程输入或者输出重定向到管道.


